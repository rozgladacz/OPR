
# Replit: wygeneruj kompletną aplikację „OPR Army Builder” (FastAPI + SQLite + Jinja2)

**Cel:** Stwórz działającą aplikację webową do budowania list armii dla gry bitewnej (wg. zmodyfikowanych zasad użytkownika), z dostępem przez WWW, wieloużytkownikową, z bazą w pliku i minimum konfiguracji. Priorytet: czytelny UI do tworzenia i wyświetlania list (HTML, układ do druku), następnie eksport PDF (bazowy), później eksport do XLSX (opcjonalny).

---

## Wymagania techniczne (minimalna konfiguracja)
- **Język:** Python 3.11+
- **Backend:** FastAPI + Uvicorn
- **Szablony HTML:** Jinja2 (renderowane po stronie serwera)
- **Baza:** SQLite (plik w repozytorium, np. `data/opr.db`)
- **ORM:** SQLAlchemy 2.x (z Alembic opcjonalnie)
- **Sesje/logowanie:** starlette `SessionMiddleware` + prosty model użytkownika (hash haseł bcrypt)
- **Statyczne pliki:** serwowanie przez FastAPI (katalog `static/`)
- **Eksport PDF:** początkowo _druk z HTML_ (widok „printable”); dodatkowo prosty export PDF przez **ReportLab** (bez zależności systemowych)
- **Eksport XLSX (opcjonalnie):** openpyxl (w kolejnych iteracjach)
- **Styling:** Bootstrap 5 (CDN) + własny CSS w `static/css/style.css`
- **Uruchomienie w Replit:** port 8080, host 0.0.0.0

Utwórz **kompletny projekt** z plikami, kodem i szablonami – tak, aby aplikacja startowała i dało się stworzyć armię, jednostkę, broń oraz prostą rozpiskę i ją wydrukować (HTML).

---

## Struktura katalogów – utwórz dokładnie taką

```
opr_army_builder/
├─ .replit
├─ requirements.txt
├─ replit.nix                        # jeśli potrzebny dla stabilności środowiska
├─ data/
│  └─ opr.db                         # utwórz automatycznie przy starcie, jeśli brak
├─ app/
│  ├─ __init__.py
│  ├─ main.py                        # FastAPI app + mount statics + template engine + SessionMiddleware
│  ├─ config.py                      # ustawienia (SECRET_KEY, DB_URL, DEBUG)
│  ├─ db.py                          # engine, SessionLocal, Base (SQLAlchemy)
│  ├─ models.py                      # definicje modeli ORM
│  ├─ schemas.py                     # Pydantic (jeśli potrzebne do API)
│  ├─ security.py                    # hash/verify bcrypt, dependency current_user
│  ├─ services/
│  │  ├─ costs.py                    # kalkulator kosztów (MVP + TODO pełne tabele)
│  │  └─ utils.py                    # pomocnicze
│  ├─ routers/
│  │  ├─ auth.py                     # rejestracja/logowanie/wylogowanie (sesje)
│  │  ├─ armory.py                   # CRUD broni
│  │  ├─ armies.py                   # CRUD armii + jednostek
│  │  ├─ rosters.py                  # tworzenie/edycja rozpisek
│  │  └─ export.py                   # /rosters/{id}/print (HTML), /rosters/{id}/pdf (ReportLab MVP)
│  ├─ templates/
│  │  ├─ base.html
│  │  ├─ index.html
│  │  ├─ auth_login.html
│  │  ├─ armory_list.html
│  │  ├─ armory_form.html
│  │  ├─ armies_list.html
│  │  ├─ army_edit.html
│  │  ├─ unit_form.html
│  │  ├─ roster_edit.html
│  │  └─ roster_print.html           # układ do druku (A4) – styl „ramka”
│  └─ static/
│     ├─ css/
│     │  └─ style.css
│     └─ js/
│        └─ app.js
└─ README.md
```

---

## Modele danych (SQLAlchemy) – zaimplementuj

> Uwaga: każdy rekord ma `id` (INT PK), `created_at`, `updated_at`. Pola `owner_id` do filtrowania „moje” vs „globalne”. Pola `parent_id` (nullable) do **dziedziczenia**.

**User**
- username (unikalny), password_hash, is_admin (bool)

**RuleSet** (na przyszłość, MVP wystarczy „Default”)
- name, config_json (opcjonalnie)

**Ability** (zdolności; typy: `unit`, `weapon`, `aura`, `active`)
- name, type, description, cost_hint (float, opcjonalny), config_json (parametry jak X itp.)

**Weapon**
- name, range (int lub str), attacks (float), ap (int), tags (np. CSV/JSON), notes (text)
- parent_id (nullable), owner_id (nullable), army_id (nullable)
- cached_cost (float, opcjonalny)

**Army**
- name, ruleset_id (fk), parent_id (nullable), owner_id (nullable)

**Unit**
- name, quality (int 2–6), defense (int 2–6), toughness (int), default_weapon_id (fk, nullable)
- flags (JSON, np. „good_shot”, „bad_shot”, „flying” – opcjonalnie)
- parent_id (nullable), army_id (fk), owner_id (nullable)

**UnitAbility** (M:N)
- unit_id, ability_id, params_json (np. X dla Strach(X))

**Roster**
- name, army_id (fk), owner_id (fk), points_limit (int, nullable)

**RosterUnit** (pozycja na liście)
- roster_id (fk), unit_id (fk), count (int)
- selected_weapon_id (fk, nullable)  # jeśli zmieniono domyślną
- extra_weapons_json (opcjonalnie)   # lista dodatkowych
- cached_cost (float, opcjonalny)

Relacje: Army 1–N Unit, Unit M–N Ability, Roster 1–N RosterUnit.

---

## Kalkulator kosztów – MVP (w `services/costs.py`)

Zaimplementuj funkcje:
- `base_model_cost(quality:int, defense:int, toughness:int, flags:dict) -> float`
- `weapon_cost(w: Weapon, unit_flags:dict) -> float`
- `abilities_cost(unit_abilities: list[Ability], toughness:int) -> float`
- `unit_total_cost(unit, overrides) -> float`  # baza + (broń) + (zdolności), przeskalowane przez liczbę modeli
- `roster_total_cost(roster_id) -> float`

**MVP:** zaimplementuj *pełny* wzór bazowy oraz strukturę pod tabele modyfikatorów, ale wypełnij _część_ wartości (resztę przygotuj jako TODO/konfigurację w słowniku), tak aby aplikacja liczyła sensowne koszty już teraz. Przygotuj czytelne miejsca do dopisania brakujących mapowań (np. AP, Rozprysk/Zabójczy, Namierzanie itd.).

Przykład (w kodzie jako słowniki):
- `QUALITY_MOD = {6:0.8, 5:0.9, 4:1.0, 3:1.1, 2:1.2}`
- `DEFENSE_BASE_MOD = {6:0.8, 5:1.0, 4:1.33, 3:1.67, 2:2.0}`
- `TOUGHNESS_MOD = {1:1.0, 2:2.15, 3:3.5, 6:8.0, 9:13.0, 12:18.0}`
- `RANGE_MOD = {"melee":0.6, 12:0.65, 18:1.0, 24:1.25, 30:1.45, 36:1.55}`
- `HIT_CHANCE = lambda q, flags: max(0.1, (7 - q))`  # + korekty TODO
- `ABILITY_COST_HINTS` – miejsce na koszty zdolności pasywnych/liczenie AUR, ROZKAZ itd.

Formuły w kodzie i komentarzach. Zadbaj o testy jednostkowe mini (np. `if __name__ == "__main__":` kilka assertów).

---

## Routing i strony (FastAPI + Jinja2)

**Nawigacja (w `base.html`):** Home, Zbrojownia, Armie, Listy, Zaloguj/Wyloguj.

**Widoki:**
- `GET /` – dashboard: „Moje listy” (z przyciskiem „Utwórz nową”), „Moje armie” (z przyciskiem „Utwórz nową”), link do Zbrojowni.
- **Auth** (`routers/auth.py`):
  - `GET /auth/login` (formularz), `POST /auth/login`
  - `GET /auth/register`, `POST /auth/register` (opcjonalnie)
  - `POST /auth/logout`
  - Sesje w cookie (SessionMiddleware), hasła: bcrypt hash
- **Zbrojownia** (`routers/armory.py`):
  - `GET /armory` lista broni (tabela z paginacją)
  - `GET /armory/new`, `POST /armory/new`
  - `GET /armory/{id}/edit`, `POST /armory/{id}/edit`
  - `POST /armory/{id}/delete` (zabezpiecz: jeśli używana – zablokuj/uskaż komunikat)
- **Armie i jednostki** (`routers/armies.py`):
  - `GET /armies` lista armii
  - `GET /armies/new`, `POST /armies/new`
  - `GET /armies/{id}/edit` – nagłówek armii + lista jednostek + „Dodaj jednostkę”
  - `GET /armies/{army_id}/units/new`, `POST /.../units/new`
  - `GET /units/{id}/edit`, `POST /units/{id}/edit`
  - `POST /units/{id}/delete`
  - Logika dziedziczenia: przy edycji broni odziedziczonej utwórz variant (parent_id) zamiast modyfikować globalną
- **Listy (rozpiski)** (`routers/rosters.py`):
  - `GET /rosters` lista moich rozpisek, `GET/POST /rosters/new`
  - `GET /rosters/{id}/edit` – nagłówek (limit punktów), panel dodawania jednostek (z wybranej armii), sekcja „Twoja rozpiska” (pozycje z możliwością zmiany liczebności, broni, usuwania). Na dole: suma punktów (aktywna), walidacja limitu.
  - `POST /rosters/{id}/units/add` (dodaj jednostkę), `POST /rosters/{id}/units/{ru_id}/update`, `POST /rosters/{id}/units/{ru_id}/delete`
- **Eksport** (`routers/export.py`):
  - `GET /rosters/{id}/print` – **HTML do druku** (A4, CSS: `@media print`), styl „ramka” (karty jednostek)
  - `GET /rosters/{id}/pdf` – **MVP ReportLab**: wygeneruj prosty PDF z tymi samymi danymi (nagłówek + lista pozycji).

Wszystkie widoki Jinja2 – przygotuj **realne** szablony (nie puste). Użyj Bootstrap 5 (CDN).

---

## Autoryzacja, własność obiektów, globalne dane
- Obiekty mają `owner_id` (FK do User). „Globalne” = `owner_id` NULL lub `is_admin` ownera.
- Na listach pokazuj: sekcję „Moje” i sekcję „Globalne”.
- Użytkownik niezalogowany działa jako „gość” (sesja bez `user_id`) – widzi tylko globalne i może tworzyć „tymczasowe” (owner_id NULL). (MVP: pozwól tworzyć; w przyszłości można ograniczyć.)

---

## Pliki – zawartość kluczowych

**`.replit`**
```
run = "uvicorn app.main:app --host 0.0.0.0 --port 8080"
```

**`requirements.txt`**
```
fastapi
uvicorn[standard]
jinja2
sqlalchemy>=2.0
alembic
python-multipart
passlib[bcrypt]
reportlab
openpyxl
python-dotenv
```
*(XLSX możesz dodać później; ale wpis zostaw.)*

**`app/main.py`** – zrób:
- inicjalizacja FastAPI
- konfiguracja Jinja2Templates, StaticFiles
- SessionMiddleware (SECRET z `config.py`)
- include_router dla auth, armory, armies, rosters, export
- endpoint `/` renderujący `index.html` z listami skróconymi

**`app/config.py`**
- `SECRET_KEY` (wygeneruj), `DB_URL = "sqlite:///./data/opr.db"`, `DEBUG = True` (MVP)

**`app/db.py`**
- `engine = create_engine(DB_URL, connect_args={"check_same_thread": False})`
- `SessionLocal = sessionmaker(...)`
- `Base = declarative_base()`
- dependency `get_db()`

**`app/models.py`**
- Wszystkie modele jak w sekcji „Modele danych”
- relacje, back_populates
- helper `touch_timestamps()`

**`app/security.py`**
- `hash_password`, `verify_password`
- dependency `get_current_user(optional=True)` – czytaj `user_id` z sesji

**`app/services/costs.py`**
- słowniki z MOD’ami (częściowo wypełnione) + TODO
- funkcje jak w sekcji „Kalkulator kosztów – MVP”

**Szablony** – przygotuj sensowne, działające:
- `base.html`: navbar, kontener, blok `content`
- `index.html`: kafelki/linki: „Moje listy”, „Moje armie”, „Zbrojownia”
- `armory_list.html`: tabela broni + przyciski (Nowa, Edytuj, Usuń)
- `armory_form.html`: formularz tworzenia/edycji
- `armies_list.html`: lista armii + „Nowa armia”
- `army_edit.html`: nagłówek armii; tabela jednostek; „Dodaj jednostkę”
- `unit_form.html`: formularz (nazwa, quality, defense, toughness, default_weapon, abilities multi-select – placeholder)
- `roster_edit.html`: wybór armii (na starcie), sekcja „Dodaj jednostkę”, sekcja „Twoja rozpiska” (wiersze RU), suma punktów, przycisk „Drukuj/Export”
- `roster_print.html`: wersja czytelna do druku (A4), „ramki” jednostek (nazwa, staty, zdolności, uzbrojenie, koszt cząstkowy), stopka z sumą

**CSS (`static/css/style.css`)**
- drobne poprawki + sekcja `@media print` (ukryj nawigację, marginesy A4, mniejsze fonty)

---

## Inicjalizacja bazy i dane startowe
- Przy starcie: jeśli brak `data/opr.db`, utwórz tabele.
- Stwórz użytkownika admin (username `admin`, hasło `admin` – **wypisz ostrzeżenie w logu** by zmienić).
- Dodaj `RuleSet("Default")`.
- Dodaj kilka przykładowych broni (np. „Karabin”, „Miecz”), jedną armię i 1–2 jednostki z domyślną bronią, by od razu dało się zrobić rozpiskę.

---

## Akceptacja (MVP musi przejść)
1. Aplikacja startuje na 0.0.0.0:8080 i renderuje `/`.
2. Mogę dodać broń w Zbrojowni; po odświeżeniu widzę ją na liście; zostaje w SQLite po restarcie.
3. Mogę dodać armię i jednostkę (z domyślną bronią).
4. Mogę utworzyć rozpiskę, dodać jednostkę, ustawić liczebność, zobaczyć **sumę punktów** (liczoną przez `services/costs.py`).
5. Widok `/rosters/{id}/print` pokazuje czytelny układ do druku.
6. Endpoint `/rosters/{id}/pdf` zwraca podstawowy PDF (ReportLab).
7. Prosta autoryzacja: logowanie/wylogowanie, odfiltrowanie „moje vs globalne”.

---

## Lista kolejnych iteracji (oddzielne, małe kroki do generowania)
1. Uzupełnij pełne tabele modyfikatorów i kosztów w `services/costs.py` (AP, Rozprysk/Zabójczy, Namierzanie, Ciężki, Impet, Aury/ Rozkaz wg schematu „koszt jak dla X Toughness” itp.).
2. Dodaj walidatory zasad (np. 1 zdolność aktywna na jednostkę; ograniczenia struktury armii).
3. Rozbuduj edycję zdolności (Ability) i przypinanie do jednostek (M:N; parametry X).
4. Rozszerz eksport PDF: ładny layout, kolumny, dzielenie na strony, sumy częściowe.
5. Dodaj eksport XLSX (openpyxl): arkusz „Lista”, arkusz „Zbrojownia”.
6. Warianty armii (dziedziczenie całej armii z parent_id) + kopiowanie jednostek z linkiem do rodzica.
7. „Dziedziczenie” broni: przy edycji globalnej broni w kontekście armii twórz wariant (parent_id).
8. Wyszukiwarka/filtry w Zbrojowni i Jednostkach.
9. Paginacja i sortowanie tabel (server-side).
10. Uprawnienia: tryb „gość tylko odczyt”, tworzenie własnych dopiero po zalogowaniu.

---

## Uruchomienie (Replit)
- Port 8080, komenda z `.replit`
- Po pierwszym starcie – utworzenie bazy i danych przykładowych
- Wejdź na `/armory`, `/armies`, `/rosters` i wykonaj scenariusz z sekcji „Akceptacja”

Proszę wygenerować **kompletne pliki i kod** zgodnie z powyższą specyfikacją tak, aby aplikacja była od razu używalna (MVP).
